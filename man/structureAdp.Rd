% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/structureAdp.R
\name{structureAdp}
\alias{structureAdp}
\title{Structure adp data in matrix instead of array}
\usage{
structureAdp(adp, debug = 0)
}
\arguments{
\item{adp}{an adp object \code{\link[oce:read.odf]{oce::read.odf()}}}

\item{debug}{integer value indicating level of debugging.
If this is less than 1, no debugging is done. Otherwise,
some functions will print debugging information.}
}
\value{
an adp object
}
\description{
This function identifies when v, a (signal_intensity_from_multibeam
_acoustic_doppler_velocity_sensor_in_sea_water), g (percent_good_ping),
q (correlation_magnitude), br (bottom_range), bv (bottom_velocity), ba,
bq, and bg are stored within an adp object. If v is an array, the components get
broken up into eastward_sea_water_velocity, northward_sea_water_velocity,
upward_sea_water_velocity, and indicative_error_from_multibeam_acoustic
_doppler_velocity_profiler_in_sea_water. If q is identified as an array
the data is broken up into separate data named percent_good_ping_1,
percent_good_ping_2, etc. If it is identified as a matrix, it is renamed
to be average_percent_ping. The same can be said for a, expect as
signal_intensity_from_multibeam_acoustic_doppler_velocity_sensor_in_sea_water.
For bottom tracking, all data are broken up into vectors.
If a or q are identified as raw, it turns it into number.
}
\examples{
\dontrun{
library(odfToNetCDF)
data <- getStandardData(type="adcp")
f1 <- system.file("extdata", "adcp1.ODF", package="odfToNetCDF")
f2 <- system.file("extdata", "adcp2.ODF", package="odfToNetCDF")
files <- c(f1,f2)
adp <- compileOdfToAdp(files)
adp2 <- nameReplacement(adp, data=data)
adp3 <- structureAdp(adp2)
names(adp2[['data']])
names(adp3[['data']])
}
}
